import 'dart:typed_data';
import 'package:flutter/material.dart';
import 'package:geolocator/geolocator.dart';
import 'package:get/get.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:image_picker/image_picker.dart';
import 'package:intl/intl.dart';
import 'package:myapp/controller/chat_controller.dart';
import 'package:myapp/services/storage/fire_storage.dart';
import 'package:myapp/utils/image_select.dart';
import 'package:myapp/utils/upload_image_dialogue.dart';
import '../components/message_tile.dart';
import '../model/message.dart';
import '../utils/colors.dart';


class TimestampedMessageTile extends StatefulWidget {
  final String message;
  final String sender;
  final String time;
  final bool sentByMe;
  final String gifUrl;
  final bool isGif;

  const TimestampedMessageTile({
    Key? key,
    required this.message,
    required this.sender,
    required this.time,
    required this.sentByMe,
    required this.gifUrl,
    required this.isGif,
  }) : super(key: key);

  @override
  State<TimestampedMessageTile> createState() => _TimestampedMessageTileState();
}

class _TimestampedMessageTileState extends State<TimestampedMessageTile> {
  @override
  @override
  Widget build(BuildContext context) {
    final controller = Get.find<ChatController>();

    // Check if the sender is blocked
    if (controller.isUserBlocked(widget.sender)) {
      print('Blocked user: ${widget.sender}'); // Debug log
      return Container(); // Don't display messages from blocked users
    }

    return Column(
      crossAxisAlignment:
          widget.sentByMe ? CrossAxisAlignment.end : CrossAxisAlignment.start,
      children: [
        GestureDetector(
          onTap: () {
            if (widget.isGif || _isImage(widget.gifUrl)) {
              // Display the image or GIF in a larger view when tapped
              print('Tapped on image or GIF: ${widget.gifUrl}'); // Debug log
              Navigator.of(context).push(MaterialPageRoute(
                builder: (context) {
                  return ImageScreen(imageUrl: widget.gifUrl);
                },
              ));
            }
          },
          child: Padding(
            padding: const EdgeInsets.symmetric(vertical: 3.0),
            child: Container(
              decoration: BoxDecoration(color:  widget.sentByMe ? Colors.grey.shade100 : Colors.white),
              child: MessageTile(
                message: widget.message,
                sender: widget.sender,
                sentByMe: widget.sentByMe,
                gifUrl: widget.gifUrl,
                isGif: widget.isGif,
                time: widget.time,
              ),
            ),
          ),
        ),
        // Padding for space below the timestamp
/*
        widget.sentByMe ? Padding(
          padding: const EdgeInsets.symmetric(horizontal: 12),
          child: Text(
            widget.time,
            style: const TextStyle(
              fontSize: 12,
              color: Colors.black45,
            ),
          ),
        ) : const SizedBox(),
*/
      ],
    );
  }

  bool _isImage(String url) {
    return url.toLowerCase().contains('.jpg') ||
        url.toLowerCase().contains('.jpeg') ||
        url.toLowerCase().contains('.png') ||
        url.toLowerCase().contains('.gif');
  }
}


class ImageScreen extends StatelessWidget {
  final String imageUrl;

  const ImageScreen({Key? key, required this.imageUrl}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        backgroundColor: Colors.black,
      ),
      body: Center(
        child: Hero(
          tag: imageUrl,
          child: GestureDetector(
            onTap: () {
              Navigator.pop(context);
            },
            child: Image.network(imageUrl),
          ),
        ),
      ),
    );
  }
}



class AutoGeneratedChatPage extends GetView<ChatController> {

 
    bool _isLocationAvailable() {
    // Your implementation to check if location is available
    // For example, you can use a location plugin or other relevant logic
    // Return true if location is available, false otherwise
    return true;
  }

   void _requestLocationPermission() async {
    LocationPermission permission = await Geolocator.requestPermission();

    if (permission == LocationPermission.denied) {
      print('Location permission denied'); // Debug log
      // Handle the case where the user declined to grant location permission
    }
  }


 void _performManualCheckIn() async {
    _requestLocationPermission();
    bool isLocationAvailable = await _isLocationAvailable();

    if (isLocationAvailable) {
      Position position = await Geolocator.getCurrentPosition();
      // Handle the obtained position, for example, update it in your database

      // Manually check-in the user with the obtained position
      _manualCheckIn(position);
    } else {
      print('Location not available'); // Debug log
      // Handle the case where location services are not available
    }
  }


 void _manualCheckIn(Position position) {
    // Implement your logic for manual check-in here.
    // For example, update the user's location in the database.
    // You may also update the UI or perform any other actions.
    print('Manual check-in at ${position.latitude}, ${position.longitude}'); // Debug log
  }

  int id = DateTime.now().millisecondsSinceEpoch;
  ScrollController? _scrollController; // Declare the ScrollController
  RxString recipientUserId = ''.obs;
  final Set<String> blockedUsers = {};


  void blockUser(String userId) {
    // Implement the logic to block the user
    // For example:
    blockedUsers.add(userId);
  }

  // Check if a user is blocked
  bool isUserBlocked(String userId) {
    return blockedUsers.contains(userId);
  }

  void _showInfoDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: Text(
            "Information",
            style: GoogleFonts.openSans(
              textStyle: const TextStyle(
                  fontWeight: FontWeight.bold,
                  color: AppColors.primaryColor,
                  letterSpacing: .5),
            ),
          ),
          content: Text(
            "You can chat with everyone in your current location. Press Locate me button beside (i)",
            style: GoogleFonts.openSans(
              textStyle:
                  const TextStyle(color: AppColors.primaryColor, letterSpacing: .5),
            ),
          ),
          actions: [
            TextButton(
              onPressed: () {
                Navigator.of(context).pop();
              },
              child: Text(
                "OK",
                style: GoogleFonts.openSans(
                  textStyle: const TextStyle(
                      fontWeight: FontWeight.bold,
                      color: AppColors.primaryColor,
                      letterSpacing: .5),
                ),
              ),
            ),
          ],
        );
      },
    );
  }

  void _scrollToBottom() {
    _scrollController!.animateTo(
      _scrollController!.position.maxScrollExtent,
      duration: const Duration(milliseconds: 300),
      curve: Curves.easeOut,
    );
  }
 @override
  Widget build(BuildContext context) {
    final controller = Get.find<ChatController>();
    _scrollController = ScrollController();

    return Scaffold(
      appBar: AppBar(
        centerTitle: true,
        elevation: 1,
        title: Obx(() => Text(
              "@ ${controller.streetName.value}",
              style: const TextStyle(color: Colors.black),
            )),
        backgroundColor: Colors.grey.shade100,
        iconTheme: const IconThemeData(color: Colors.black),
        actions: [
/*
          GestureDetector(
            onTap: () {
              _showInfoDialog(context);
            },
            child: Container(
              padding: const EdgeInsets.all(8),
              child: const Icon(Icons.info, color: Colors.black),
            ),
          ),
*/
          GestureDetector(
            onTap: () {
              controller.getUserLocation();
            },
            child: Padding(
              padding: const EdgeInsets.symmetric(vertical: 8.0,horizontal: 10.0),
              child: Container(
                width: 100,
                decoration: BoxDecoration(color: Colors.grey.shade400,borderRadius: BorderRadius.circular(20)),
                padding: const EdgeInsets.all(8),
                child: const Center(child: Text("Locate Me",style: TextStyle(fontSize: 14,fontWeight: FontWeight.w500,overflow: TextOverflow.ellipsis,color: Colors.black))),
              ),
            ),
          ),
        ],
      ),
      body: SafeArea(
        child: Container(
          decoration: BoxDecoration(
            color: Colors.grey.shade100,
            borderRadius: const BorderRadius.only(
              topRight: Radius.circular(40),
              topLeft: Radius.circular(40),
            ),
            border: Border.all(
              width: 3,
              color: Colors.white,
              style: BorderStyle.solid,
            ),
          ),
          child: Column(
            children: <Widget>[
              const SizedBox(
                height: 10,
              ),
              Expanded(
                child: Obx(() {
                  final reversedMessages =
                      controller.messagesList.reversed.toList();

                  return ListView.builder(
                    reverse: true,
                    controller: _scrollController,
                    physics: const BouncingScrollPhysics(),
                    padding: const EdgeInsets.only(bottom: 60),
                    itemCount: reversedMessages.length,
                    itemBuilder: (context, index) {
                      final message = reversedMessages[index];
                      final isSentByMe =
                          controller.firebaseAuth.currentUser?.uid ==
                              message.senderId;
                      return TimestampedMessageTile(
                        message: message.message,
                        sender: message.senderEmail,
                        time: _formatTimestamp(message.timestamp),
                        sentByMe: isSentByMe,
                        gifUrl: message.gifUrl,
                        isGif: message.isGif,
                      );
                    },
                  );
                }),
              ),
              _buildMessageInput(context),
            ],
          ),
        ),
      ),
    );
  }
 
  String _formatTimestamp(DateTime timestamp) {
    final format = DateFormat('hh:mm a');
    return format.format(timestamp);
  }

void _showLocationWarningDialog(BuildContext context) {
  showDialog(
    context: context,
    builder: (BuildContext context) {
      return AlertDialog(
        title: Text(
          "Location Required",
          style: GoogleFonts.openSans(
            textStyle: const TextStyle(
              fontWeight: FontWeight.bold,
              color: AppColors.primaryColor,
              letterSpacing: .5,
            ),
          ),
        ),
        content: Text(
          "Please press the 'Locate Me' button before chatting.",
          style: GoogleFonts.openSans(
            textStyle: const TextStyle(
              color: AppColors.primaryColor,
              letterSpacing: .5,
            ),
          ),
        ),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.of(context).pop();
            },
            child: Text(
              "OK",
              style: GoogleFonts.openSans(
                textStyle: const TextStyle(
                  fontWeight: FontWeight.bold,
                  color: AppColors.primaryColor,
                  letterSpacing: .5,
                ),
              ),
            ),
          ),
        ],
      );
    },
  );
}
Widget _buildMessageInput(BuildContext context) {
  final controller = Get.find<ChatController>();

  return Padding(
    padding: const EdgeInsets.all(8.0),
    child: Row(
      children: [
        Obx(() {
          if (controller.selectedGifUrl.value.isEmpty) {
            return Container();
          } else {
            return Stack(
              children: [
                Image.network(
                  controller.selectedGifUrl.value,
                  height: 50,
                  width: 50,
                  fit: BoxFit.cover,
                ),
                IconButton(
                  icon: const Icon(
                    Icons.delete,
                    color: Colors.red,
                  ),
                  onPressed: () {
                    controller.selectedGifUrl.value = '';
                  },
                ),
              ],
            );
          }
        }),
        IconButton(
          icon: const Icon(Icons.camera_alt, color: AppColors.primaryColor),
          onPressed: () {
            showUploadOption(
              context,
              () async {
                Uint8List? imageCode =
                    await handleImageUpload(ImageSource.gallery);
                if (imageCode != null) {
                  try {
                    String imageUrl = await StorageMethods()
                        .uploadImageToStorage(
                            'autogen/${controller.getstreetName}/$id/',
                            imageCode,
                            false);
                    controller.selectedGifUrl.value = imageUrl;
                    if (context.mounted) {
                      Navigator.of(context).pop();
                    }
                  } catch (e) {
                    print('error occurred: $e');
                  }
                }
              },
              () async {
                Uint8List? imageCode =
                    await handleImageUpload(ImageSource.camera);
                if (imageCode != null) {
                  try {
                    String imageUrl = await StorageMethods()
                        .uploadImageToStorage(
                            'autogen/${controller.getstreetName}/$id/',
                            imageCode,
                            false);
                    controller.selectedGifUrl.value = imageUrl;
                    if (context.mounted) {
                      Navigator.of(context).pop();
                    }
                  } catch (e) {
                    print('error occurred: $e');
                  }
                }
              },
              true,
            );
          },
        ),
        IconButton(
          icon: const Icon(Icons.gif),
          onPressed: () {
            showModalBottomSheet(
              context: context,
              builder: (context) => SizedBox(
                height: MediaQuery.of(context).size.height * 0.7,
                child: Column(
                  children: [
                    SizedBox(height: 10,),
                    TextFormField(
                      textInputAction: TextInputAction.done,
                      onFieldSubmitted: (term) {
                        controller.searchByGifName();
                      },
                      controller: controller.searchGifText.value,
                      decoration: InputDecoration(
                        labelText: 'Search Gif...',
                        labelStyle: const TextStyle(
                            color: AppColors.primaryColor),
                        suffixIcon: Obx(
                              () => controller.isSeachActive.value
                              ? IconButton(
                            icon: const Icon(Icons.close,
                                color: AppColors.primaryColor),
                            onPressed: controller.cancelSearch,
                          )
                              : IconButton(
                            icon: const Icon(Icons.search,
                                color: AppColors.primaryColor),
                            onPressed: controller.searchByGifName,
                          ),
                        ),
                        enabledBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(20),
                          borderSide: BorderSide.none,
                        ),
                        focusedBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(20),
                          borderSide: const BorderSide(
                              color: AppColors.primaryColor),
                        ),
                        filled: true,
                        fillColor: Colors.white,
                      ),
                    ),
                    Expanded(
                      child: Obx(() => GridView.builder(
                        gridDelegate:
                        const SliverGridDelegateWithFixedCrossAxisCount(
                          crossAxisCount: 3,
                          mainAxisSpacing: 8.0,
                          crossAxisSpacing: 8.0,
                        ),
                        padding: const EdgeInsets.all(8.0),
                        itemCount: controller.gifUrl.length,
                        itemBuilder: (context, index) {
                          return GestureDetector(
                            onTap: () {
                              controller.selectedGifUrl.value =
                              controller.gifUrl[index];
                              Navigator.pop(context);
                            },
                            child: Image.network(
                              controller.gifUrl[index],
                            ),
                          );
                        },
                      )),
                    ),
                  ],
                ),
              ),
            );
          },
        ),
        IconButton(
          icon: const Icon(Icons.block, color: AppColors.primaryColor),
          onPressed: () {
            _showBlockDialog(context, controller.getstreetName!);
          },
        ),
        Flexible(
          child: TextField(
            controller: controller.messageTextCont,
            onSubmitted: sendMessage,
            decoration: const InputDecoration.collapsed(
              hintText: 'Send a message',
            ),
            maxLines: null,
            textInputAction: TextInputAction.newline,
            enabled: controller.isLocationSet.value,
          ),
        ),
        IconButton(
          icon: const Icon(
            Icons.send,
            color: AppColors.primaryColor,
          ),
          onPressed: () {
            if (controller.isLocationSet.value) {
              sendMessage('');
            } else {
              _showLocationWarningDialog(context);
            }
          },
        ),
      ],
    ),
  );
}


  void _showBlockDialog(BuildContext context, String sender) {
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: Text(
            "Block User",
            style: GoogleFonts.openSans(
              textStyle: const TextStyle(
                  fontWeight: FontWeight.bold,
                  color: AppColors.primaryColor,
                  letterSpacing: .5),
            ),
          ),
          content: Text(
            "Do you want to block messages from $sender?",
            style: GoogleFonts.openSans(
              textStyle:
                  const TextStyle(color: AppColors.primaryColor, letterSpacing: .5),
            ),
          ),
          actions: [
            TextButton(
              onPressed: () {
                Navigator.of(context).pop();
              },
              child: Text(
                "Cancel",
                style: GoogleFonts.openSans(
                  textStyle: const TextStyle(
                      fontWeight: FontWeight.bold,
                      color: AppColors.primaryColor,
                      letterSpacing: .5),
                ),
              ),
            ),
            TextButton(
              onPressed: () {
                // Call the method to block the user
                controller.blockUser(sender);
                Navigator.of(context).pop();
              },
              child: Text(
                "Block",
                style: GoogleFonts.openSans(
                  textStyle: const TextStyle(
                      fontWeight: FontWeight.bold,
                      color: AppColors.primaryColor,
                      letterSpacing: .5),
                ),
              ),
            ),
          ],
        );
      },
    );
  }

 void sendMessage(String text) {
  final controller = Get.find<ChatController>();

  if (controller.isLocationSet.value) {
    final DateTime timestamp = DateTime.now();

    Map<String, dynamic> chatMessageMap = {
      "sender": controller.firebaseAuth.currentUser?.uid,
      "sendername": controller.firebaseAuth.currentUser?.email?.substring(0, 6),
      "time": timestamp,
    };
    chatMessageMap['message'] = controller.messageTextCont.text;

    if (controller.messageTextCont.text.toString().trim().isNotEmpty ||
        controller.selectedGifUrl.value.isNotEmpty) {
      controller.addAMessageToDB(
        messageVal: MessagePublicChat(
          senderId: controller.firebaseAuth.currentUser!.uid,
          message: controller.messageTextCont.text.toString().trim(),
          timestamp: timestamp,
          senderEmail: controller.firebaseAuth.currentUser!.email!,
          gifUrl: controller.selectedGifUrl.value,
          isGif: controller.selectedGifUrl.value.isNotEmpty,
        ),
      );
      controller.selectedGifUrl.value = '';
    }
  } else {
    // Location not set, show a warning message or take appropriate action
    _showLocationWarningDialog(Get.context!);
  }
}


}
